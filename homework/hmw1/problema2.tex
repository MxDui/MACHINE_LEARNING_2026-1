\section*{2. [2.5 puntos] Clases de hipótesis}

Para una clase de hipótesis de elipses $\mathcal{H}_{\text{eli}}$ donde un elipse con centro en la coordenada $(h, k)$ se describe con la siguiente ecuación:

\begin{equation}
\frac{(x - h)^2}{a^2} + \frac{(y - k)^2}{b^2} = 1
\end{equation}

donde $a > 0$ y $b > 0$ son los parámetros para los semiejes del elipse.

\begin{enumerate}
    \item[a)] Usa esta ecuación para escribir una función indicadora para evaluar si un punto en 2D pertenece o no a una hipótesis de un elipse particular $h_{\boldsymbol{\theta}} \in \mathcal{H}_{\text{eli}}$, donde $\boldsymbol{\theta} = \{h, k, a, b\}$.
    
    \textbf{Solución:}
    
    La función indicadora para un elipse parametrizado por $\boldsymbol{\theta} = \{h, k, a, b\}$ se define como:
    
    $$h_{\boldsymbol{\theta}}(x,y) = \begin{cases}
    1 & \text{si } \frac{(x - h)^2}{a^2} + \frac{(y - k)^2}{b^2} \leq 1 \\
    0 & \text{en caso contrario}
    \end{cases}$$
    
    donde:
    \begin{itemize}
        \item $(h, k)$ es el centro del elipse
        \item $a$ es el semieje mayor (o menor) en la dirección $x$
        \item $b$ es el semieje mayor (o menor) en la dirección $y$
        \item $a, b > 0$
    \end{itemize}
    
    Un punto $(x,y)$ pertenece al interior del elipse (incluyendo la frontera) cuando la expresión normalizada es menor o igual a 1.
    
    
    \item[b)] Escribe a manera de pseudocódigo un algoritmo para encontrar los parámetros $\boldsymbol{\theta}' = \{h', k', a', b'\}$ del elipse más pequeño que sólo permite un error menor o igual al 10\% de clasificaciones incorrectas (para una de dos clases) del total de puntos $\mathcal{X} = \{(x_1, y_1), (x_2, y_2), \ldots, (x_n, y_n)\}$.
    
    \textbf{Solución:}
    
    \begin{verbatim}
    ALGORITMO: Encontrar_Elipse_Minimo_Con_Tolerancia
    
    ENTRADA: 
    - X: conjunto de puntos {(x_i, y_i)}
    - Y: etiquetas {+1, -1}
    - tolerancia: 0.1 (10% error máximo)
    
    1. Separar puntos por clase:
       X_pos = {puntos con etiqueta +1}
       X_neg = {puntos con etiqueta -1}
       n = |X|
       max_errores = floor(tolerancia * n)
    
    2. Inicializar elipse mínimo para puntos positivos:
       h' = media(x_i) para i en X_pos
       k' = media(y_i) para i en X_pos  
       a' = 2 * desviacion_estandar(x_i) para i en X_pos
       b' = 2 * desviacion_estandar(y_i) para i en X_pos
    
    3. Ajustar tamaño del elipse:
       factor_escala = 0.1
       MIENTRAS contar_errores(X, Y, {h', k', a', b'}) > max_errores:
           a' = a' * (1 + factor_escala)
           b' = b' * (1 + factor_escala)
    
    4. RETORNAR theta' = {h', k', a', b'}
    
    FUNCIÓN contar_errores(X, Y, theta):
        errores = 0
        PARA cada punto (x_i, y_i) con etiqueta y_i:
            prediccion = h_theta(x_i, y_i)
            etiqueta_esperada = 1 si y_i == +1, sino 0
            SI prediccion != etiqueta_esperada:
                errores += 1
        RETORNAR errores
    \end{verbatim}
    
    
    \item[c)] Ahora encuentra también a manera de pseudocódigo los parámetros del elipse más grande que no introduce nuevos errores. Puedes partir de los parámetros $\boldsymbol{\theta}'$ del inciso anterior.
    
    \textbf{Solución:}
    
    \begin{verbatim}
    ALGORITMO: Encontrar_Elipse_Maximo_Sin_Nuevos_Errores
    
    ENTRADA: 
    - X, Y: puntos y etiquetas
    - theta' = {h', k', a', b'}: parametros del elipse minimo del inciso b)
    
    1. Calcular errores actuales:
       errores_iniciales = contar_errores(X, Y, theta')
    
    2. Calcular distancia normalizada de puntos negativos al elipse:
       distancias_neg = []
       PARA cada punto (x_i, y_i) con etiqueta -1:
           dist_norm = sqrt((x_i - h')²/a'² + (y_i - k')²/b'²)
           SI dist_norm < 1:  # Punto negativo dentro del elipse
               distancias_neg.append(1 - dist_norm)
           SINO:
               distancias_neg.append(dist_norm - 1)
    
    3. Encontrar el factor de expansión máximo:
       factor_max = 1.0
       epsilon = 1e-6
       
       PARA cada punto negativo (x_i, y_i) FUERA del elipse:
           # Calcular factor máximo sin incluir este punto
           dist_norm = sqrt((x_i - h')²/a'² + (y_i - k')²/b'²)
           factor_candidato = 1 / dist_norm - epsilon
           factor_max = max(factor_max, factor_candidato)
    
    4. Expandir el elipse:
       a'' = a' * factor_max
       b'' = b' * factor_max
       theta'' = {h', k', a'', b''}
    
    5. Verificar que no se introduzcan nuevos errores:
       SI contar_errores(X, Y, theta'') > errores_iniciales:
           # Reducir factor de expansión iterativamente
           factor_max = factor_max * 0.99
           REPETIR paso 4 y 5
    
    6. RETORNAR theta'' = {h', k', a'', b''}
    \end{verbatim}
    
    
    \item[d)] Finalmente propón como hipótesis para la función indicadora un elipse que esté entre ambos (de los incisos b y c), por ejemplo a la mitad del camino paramétricamente hablando.
    
    \textbf{Solución:}
    
    La hipótesis final se obtiene mediante interpolación lineal entre los dos elipses:
    
    $$\boldsymbol{\theta}_{\text{final}} = \alpha \boldsymbol{\theta}' + (1-\alpha) \boldsymbol{\theta}''$$
    
    donde $\alpha = 0.5$ para obtener el punto medio.
    
    Específicamente:
    \begin{align}
    h_{\text{final}} &= h' \quad \text{(el centro no cambia)} \\
    k_{\text{final}} &= k' \quad \text{(el centro no cambia)} \\
    a_{\text{final}} &= \frac{a' + a''}{2} \\
    b_{\text{final}} &= \frac{b' + b''}{2}
    \end{align}
    
    Por tanto, la función indicadora final es:
    
    $$h_{\text{final}}(x,y) = \begin{cases}
    1 & \text{si } \frac{(x - h')^2}{a_{\text{final}}^2} + \frac{(y - k')^2}{b_{\text{final}}^2} \leq 1 \\
    0 & \text{en caso contrario}
    \end{cases}$$
    
    Esta elección balanceada permite un compromiso entre el elipse más pequeño (que minimiza el error de entrenamiento) y el elipse más grande (que maximiza el margen), lo que puede resultar en mejor generalización.
    
    
    \item[e)] Implementarás esto en la práctica asociada a este ejercicio.
\end{enumerate}

