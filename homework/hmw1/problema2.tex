\section*{2. [2.5 puntos] Clases de hipótesis}

Para una clase de hipótesis de elipses $\mathcal{H}_{\text{eli}}$ donde un elipse con centro en la coordenada $(h, k)$ se describe con la siguiente ecuación:

\begin{equation}
\frac{(x - h)^2}{a^2} + \frac{(y - k)^2}{b^2} = 1
\end{equation}

donde $a > 0$ y $b > 0$ son los parámetros para los semiejes del elipse.

\begin{enumerate}
    \item[a)] Usa esta ecuación para escribir una función indicadora para evaluar si un punto en 2D pertenece o no a una hipótesis de un elipse particular $h_{\boldsymbol{\theta}} \in \mathcal{H}_{\text{eli}}$, donde $\boldsymbol{\theta} = \{h, k, a, b\}$.
    
    \textbf{Solución:}
    
    La función indicadora para un elipse parametrizado por $\boldsymbol{\theta} = \{h, k, a, b\}$ se define como:
    
    $$h_{\boldsymbol{\theta}}(x,y) = \begin{cases}
    1 & \text{si } \frac{(x - h)^2}{a^2} + \frac{(y - k)^2}{b^2} \leq 1 \\
    0 & \text{en caso contrario}
    \end{cases}$$
    
    donde:
    \begin{itemize}
        \item $(h, k)$ es el centro del elipse
        \item $a$ es el semieje mayor (o menor) en la dirección $x$
        \item $b$ es el semieje mayor (o menor) en la dirección $y$
        \item $a, b > 0$
    \end{itemize}
    
    Un punto $(x,y)$ pertenece al interior del elipse (incluyendo la frontera) cuando la expresión normalizada es menor o igual a 1.
    
    
    \item[b)] Escribe a manera de pseudocódigo un algoritmo para encontrar los parámetros $\boldsymbol{\theta}' = \{h', k', a', b'\}$ del elipse más pequeño que sólo permite un error menor o igual al 10\% de clasificaciones incorrectas (para una de dos clases) del total de puntos $\mathcal{X} = \{(x_1, y_1), (x_2, y_2), \ldots, (x_n, y_n)\}$.
    
    \textbf{Solución:}
    
    \begin{verbatim}
    ALGORITMO: Elipse_Minimo_Con_Tolerancia (búsqueda por escalamiento)
    
    ENTRADA:
    - X: conjunto de puntos {(x_i, y_i)}
    - Y: etiquetas en {+1, -1} (interior = +1)
    - tolerancia: 0.1 (10% error máximo)
    
    1. Separar por clase y fijar presupuesto de error:
       X_pos = { (x_i, y_i) | Y_i = +1 }
       X_neg = { (x_i, y_i) | Y_i = -1 }
       n = |X|
       max_errores = floor(tolerancia * n)
    
    2. Estimar centro y forma base con la clase positiva:
       h' = media(x | (x,y) en X_pos)
       k' = media(y | (x,y) en X_pos)
       eps = 1e-9
       a0 = desviacion_estandar(x | (x,y) en X_pos) + eps
       b0 = desviacion_estandar(y | (x,y) en X_pos) + eps
    
    3. Precomputar distancias normalizadas respecto a (h', k', a0, b0):
       Para cada punto (x_i, y_i):
           d_i = sqrt( (x_i - h')^2 / a0^2 + (y_i - k')^2 / b0^2 )
    
    4. Construir lista de escalas candidatas:
       S = valores_únicos_ordenados({ d_i : i = 1..n })
       # Clasificación con escala s: pred_i(s) = +1 si d_i <= s, \
       # en otro caso -1
    
    5. Encontrar el menor s que cumple el presupuesto:
       mejor_s = None
       mejor_err = +infinito
       PARA cada s en S (en orden ascendente):
           errores = contar_errores_con_s(d, Y, s)
           SI errores < mejor_err:
               mejor_err = errores
           SI errores <= max_errores y (mejor_s es None):
               mejor_s = s   # es el más pequeño por el orden
               # opcional: si mejor_err == 0, romper
       SI mejor_s es None:
           # No hay s que cumpla; tomar el s con menor #errores (y el más \
           # pequeño en caso de empate)
           mejor_s = argmin_por((errores(s), s), s en S)
    
    6. Definir el elipse mínimo:
       a' = a0 * mejor_s
       b' = b0 * mejor_s
       theta' = {h', k', a', b'}
       RETORNAR theta'
    
    FUNCIÓN contar_errores_con_s(d, Y, s):
        errores = 0
        PARA i = 1..n:
            pred = +1 si d_i <= s, en otro caso -1
            SI pred != Y_i: errores += 1
        RETORNAR errores
    \end{verbatim}
    
    
    \item[c)] Ahora encuentra también a manera de pseudocódigo los parámetros del elipse más grande que no introduce nuevos errores. Puedes partir de los parámetros $\boldsymbol{\theta}'$ del inciso anterior.
    
    \textbf{Solución:}
    
    \begin{verbatim}
    ALGORITMO: Elipse_Maximo_Sin_Nuevos_Errores (expansión segura)
    
    ENTRADA:
    - X, Y: puntos y etiquetas
    - theta' = {h', k', a', b'}: elipse mínimo del inciso b)
    
    1. errores_iniciales = contar_errores(X, Y, theta')
    
    2. Para cada punto negativo (Y_i = -1), calcular
       d_i = sqrt( (x_i - h')^2 / a'^2 + (y_i - k')^2 / b'^2 )
    
    3. Factor de expansión máximo que no introduce nuevos errores:
       # Al escalar a', b' por s > 1, las nuevas distancias son d_i / s.
       candidatos = { d_i : Y_i = -1 y d_i > 1 }
       SI candidatos no vacío:
           s_max = min(candidatos) - epsilon   # asegura que ningún negativo \
                                               # fuera cruce a d<=1
           s_max = max(s_max, 1.0)
       EN OTRO CASO:
           s_max = 1.0   # cualquier expansión introduciría nuevos FP si ya \
                       # hay negativos en el borde
       
    4. Definir el elipse expandido:
       a'' = a' * s_max
       b'' = b' * s_max
       theta'' = {h', k', a'', b''}
    
    5. Verificación:
       SI contar_errores(X, Y, theta'') > errores_iniciales:
           s_max = s_max * 0.999  # reducir ligeramente y volver a probar
           repetir paso 4 y 5 hasta cumplir
    
    6. RETORNAR theta''
    
    FUNCIÓN contar_errores(X, Y, {h, k, a, b}):
        errores = 0
        PARA cada (x_i, y_i), Y_i:
            d = sqrt( (x_i - h)^2 / a^2 + (y_i - k)^2 / b^2 )
            pred = +1 si d <= 1, en otro caso -1
            SI pred != Y_i: errores += 1
        RETORNAR errores
    \end{verbatim}
    
    
    \item[d)] Finalmente propón como hipótesis para la función indicadora un elipse que esté entre ambos (de los incisos b y c), por ejemplo a la mitad del camino paramétricamente hablando.
    
    \textbf{Solución:}
    
    La hipótesis final se obtiene mediante interpolación lineal entre los dos elipses:
    
    $$\boldsymbol{\theta}_{\text{final}} = \alpha \boldsymbol{\theta}' + (1-\alpha) \boldsymbol{\theta}''$$
    
    donde $\alpha = 0.5$ para obtener el punto medio.
    
    Específicamente:
    \begin{align}
    h_{\text{final}} &= h' \quad \text{(el centro no cambia)} \\
    k_{\text{final}} &= k' \quad \text{(el centro no cambia)} \\
    a_{\text{final}} &= \frac{a' + a''}{2} \\
    b_{\text{final}} &= \frac{b' + b''}{2}
    \end{align}
    
    Por tanto, la función indicadora final es:
    
    $$h_{\text{final}}(x,y) = \begin{cases}
    1 & \text{si } \frac{(x - h')^2}{a_{\text{final}}^2} + \frac{(y - k')^2}{b_{\text{final}}^2} \leq 1 \\
    0 & \text{en caso contrario}
    \end{cases}$$
    
    Esta elección balanceada permite un compromiso entre el elipse más pequeño (que minimiza el error de entrenamiento) y el elipse más grande (que maximiza el margen), lo que puede resultar en mejor generalización.
    
    
    \item[e)] Implementarás esto en la práctica asociada a este ejercicio.
\end{enumerate}

